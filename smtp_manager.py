#!/usr/bin/env python3
"""
smtp_send_env.py — SMTP email automation with environment/.env support

This script can:
- Read configuration from environment variables (preferred) or a .env file (if present).
- Fall back to interactive prompts when necessary.
- Send email over SSL (465), STARTTLS (587), or no security.
- Support attachments from /resource/attachments directory.
- Send HTML-only emails (subject, recipients, and HTML body are defined in script).

Unit tests are located in test_smtp.py (run with: python -m unittest test_smtp.py)

Environment variables (examples)
--------------------------------
SMTP_HOST=smtp.gmail.com
SMTP_PORT=465
SMTP_SECURITY=SSL        # SSL, STARTTLS, or NONE
SMTP_USERNAME=you@example.com
SMTP_PASSWORD=your_app_password
SMTP_SENDER=you@example.com
EMAIL_TIMEOUT=10
EMAIL_NONINTERACTIVE=1   # If set to 1 and required fields present, the script will send without prompts

Note: Subject, recipients, and HTML body are defined in the script (EMAIL_SUBJECT, EMAIL_RECIPIENTS, EMAIL_HTML_BODY).
Attachments are automatically loaded from /resource/attachments directory.

.env file
---------
If a .env file exists in the current working directory it will be read for defaults.
Environment variables take precedence over .env values.

Security note for Gmail
-----------------------
Use an App Password if your Google account has 2FA enabled.
OAuth2 is not implemented here.

Author
------
Generated by ChatGPT (GPT-5 Thinking mini).
"""

from __future__ import annotations
import os
import sys
import getpass
import mimetypes
from typing import List, Optional, Tuple, Dict
import smtplib
import ssl
from email.message import EmailMessage

# -------------------------
# Email Content Configuration (defined in script)
# -------------------------
EMAIL_SUBJECT = "Your Email Subject Here"
EMAIL_RECIPIENTS = [
    "manual20151276@gmail.com",
    "ydleesong@gmail.com",
]
EMAIL_HTML_BODY = """
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Email</title>
</head>
<body>
    <h1>Hello</h1>
    <p>This is your HTML email body.</p>
</body>
</html>
"""

# -------------------------
# Config: load .env and environment
# -------------------------
def load_dotenv_file(path: str) -> Dict[str, str]:
    """
    Minimal .env parser: reads KEY=VALUE pairs, ignores comments and blank lines.
    Returns a dict of key->value.
    """
    result: Dict[str, str] = {}
    try:
        with open(path, "r", encoding="utf-8") as fh:
            for raw in fh:
                line = raw.strip()
                if not line or line.startswith("#"):
                    continue
                if "=" not in line:
                    continue
                key, val = line.split("=", 1)
                key = key.strip()
                val = val.strip()
                # strip surrounding quotes if any
                if (val.startswith('"') and val.endswith('"')) or (val.startswith("'") and val.endswith("'")):
                    val = val[1:-1]
                result[key] = val
    except FileNotFoundError:
        pass
    except Exception:
        # If file exists but cannot be parsed fully, ignore parsing errors and return what we got.
        pass
    return result

def merged_config(dotenv_path: str = ".env") -> Dict[str, str]:
    """
    Merge os.environ over values found in .env (if present).
    """
    cfg = load_dotenv_file(dotenv_path)
    # Overlay with actual environment variables
    for k, v in os.environ.items():
        cfg[k] = v
    return cfg

# -------------------------
# Sending logic
# -------------------------
def get_attachments_from_directory(directory: str) -> List[str]:
    """
    Get all files from the specified directory.
    Returns a list of full file paths.
    """
    attachments = []
    if not os.path.isdir(directory):
        return attachments
    try:
        for item in os.listdir(directory):
            item_path = os.path.join(directory, item)
            if os.path.isfile(item_path):
                attachments.append(item_path)
    except Exception:
        pass
    return attachments

def send_email(
    smtp_host: str,
    port: int,
    security: str,  # 'SSL', 'STARTTLS', 'NONE'
    username: str,
    password: str,
    sender: str,
    recipients: List[str],
    subject: str,
    body_html: str,
    attachments: Optional[List[str]] = None,
    timeout: int = 10
) -> Tuple[bool, Optional[str]]:
    """
    Build and send an email with HTML body only.

    Returns:
        (True, None) on success; (False, error_message) on failure.
    """
    msg = EmailMessage()
    msg["From"] = sender
    msg["To"] = ", ".join(recipients)
    msg["Subject"] = subject
    msg.set_content(body_html, subtype="html")

    # Attach files if any
    if attachments:
        for fp in attachments:
            fp = os.path.expanduser(fp)
            if not os.path.isfile(fp):
                return False, f"Attachment not found: {fp}"
            ctype, encoding = mimetypes.guess_type(fp)
            if ctype is None:
                ctype = "application/octet-stream"
            maintype, subtype = ctype.split("/", 1)
            try:
                with open(fp, "rb") as f:
                    data = f.read()
                msg.add_attachment(data, maintype=maintype, subtype=subtype,
                                   filename=os.path.basename(fp))
            except Exception as exc:
                return False, f"Failed to attach {fp}: {exc}"

    # Connect and send
    try:
        if security.upper() == "SSL":
            context = ssl.create_default_context()
            with smtplib.SMTP_SSL(smtp_host, port, context=context, timeout=timeout) as server:
                server.login(username, password)
                server.send_message(msg)
        elif security.upper() == "STARTTLS":
            with smtplib.SMTP(smtp_host, port, timeout=timeout) as server:
                server.ehlo()
                server.starttls(context=ssl.create_default_context())
                server.ehlo()
                server.login(username, password)
                server.send_message(msg)
        elif security.upper() == "NONE":
            with smtplib.SMTP(smtp_host, port, timeout=timeout) as server:
                server.login(username, password)
                server.send_message(msg)
        else:
            return False, f"Unknown security option: {security}"
    except smtplib.SMTPAuthenticationError:
        return False, "Authentication failed — check username / app password."
    except smtplib.SMTPException as e:
        return False, f"SMTP error: {e}"
    except Exception as e:
        return False, f"Connection/other error: {e}"

    return True, None

# -------------------------
# Helpers and interactive UI
# -------------------------
def _input_list(prompt: str) -> List[str]:
    val = input(prompt).strip()
    if not val:
        return []
    sep = ";" if ";" in val and "," not in val else ","
    return [p.strip() for p in val.split(sep) if p.strip()]

def _split_list_env(value: Optional[str]) -> List[str]:
    if not value:
        return []
    sep = ";" if ";" in value and "," not in value else ","
    return [p.strip() for p in value.split(sep) if p.strip()]

def interactive_main_with_config(config: Dict[str, str]):
    print("=== Simple SMTP Email Sender (env/.env support) ===")
    print("Press Enter to accept defaults where shown.\n")

    smtp_host = config.get("SMTP_HOST") or input("SMTP server (default: smtp.gmail.com): ").strip() or "smtp.gmail.com"

    port_in_default = config.get("SMTP_PORT")
    port_in = port_in_default or input("Port (default: 465 for SSL, 587 for STARTTLS): ").strip() or port_in_default or ""
    try:
        port = int(port_in) if port_in else 465
    except ValueError:
        print("Invalid port. Using 465.")
        port = 465

    sec_default = config.get("SMTP_SECURITY", "SSL")
    sec = sec_default or input("Security [SSL/STARTTLS/NONE] (default: SSL): ").strip() or "SSL"
    if not port_in:
        port = 465 if sec.upper() == "SSL" else 587 if sec.upper() == "STARTTLS" else 25

    username = config.get("SMTP_USERNAME") or input("SMTP username (your email): ").strip()
    if not username:
        print("Username required.")
        return

    # Password: prefer env, otherwise ask securely (or from .env file)
    password = config.get("SMTP_PASSWORD")
    if not password:
        password = getpass.getpass("SMTP password / app password (hidden): ").strip()
    if not password:
        print("Password required.")
        return

    sender = config.get("SMTP_SENDER") or input(f"From email address (default: {username}): ").strip() or username

    # Use recipients from script configuration
    to_list = EMAIL_RECIPIENTS
    if not to_list:
        print("No recipients defined in script.")
        return

    # Use subject from script configuration
    subject = EMAIL_SUBJECT

    # Use HTML body from script configuration
    body_html = EMAIL_HTML_BODY
    if not body_html:
        print("No HTML body defined in script.")
        return

    # Get attachments from /resource/attachments directory
    attachments_dir = os.path.join(os.path.dirname(__file__), "resource", "attachments")
    attachments = get_attachments_from_directory(attachments_dir)
    if not attachments:
        print(f"No attachments found in {attachments_dir}")
        attachments = None
    else:
        print(f"Found {len(attachments)} attachment(s) in {attachments_dir}")

    timeout = int(config.get("EMAIL_TIMEOUT", "10"))

    print("\nSending...")
    ok, err = send_email(
        smtp_host=smtp_host,
        port=port,
        security=sec,
        username=username,
        password=password,
        sender=sender,
        recipients=to_list,
        subject=subject,
        body_html=body_html,
        attachments=attachments,
        timeout=timeout
    )
    if ok:
        print("Email sent successfully.")
    else:
        print("Failed to send email:", err)

def noninteractive_send_if_possible(config: Dict[str, str]) -> Optional[Tuple[bool, Optional[str]]]:
    """
    If EMAIL_NONINTERACTIVE==1 (or truthy) and required fields are present in config,
    perform a non-interactive send and return the (ok, err) tuple. Otherwise return None.
    Required keys: SMTP_USERNAME, SMTP_PASSWORD, SMTP_SENDER
    Subject, recipients, and HTML body are defined in script.
    """
    if not config.get("EMAIL_NONINTERACTIVE") or config.get("EMAIL_NONINTERACTIVE") in ("0", "false", "False", ""):
        return None
    required = ["SMTP_USERNAME", "SMTP_PASSWORD", "SMTP_SENDER"]
    for k in required:
        if not config.get(k):
            return None
    # build parameters
    smtp_host = config.get("SMTP_HOST", "smtp.gmail.com")
    port = int(config.get("SMTP_PORT", "465"))
    sec = config.get("SMTP_SECURITY", "SSL")
    username = config["SMTP_USERNAME"]
    password = config["SMTP_PASSWORD"]
    sender = config["SMTP_SENDER"]
    # Use values from script configuration
    recipients = EMAIL_RECIPIENTS
    subject = EMAIL_SUBJECT
    body_html = EMAIL_HTML_BODY
    # Get attachments from /resource/attachments directory
    attachments_dir = os.path.join(os.path.dirname(__file__), "resource", "attachments")
    attachments = get_attachments_from_directory(attachments_dir)
    if not attachments:
        attachments = None
    timeout = int(config.get("EMAIL_TIMEOUT", "10"))

    return send_email(
        smtp_host=smtp_host,
        port=port,
        security=sec,
        username=username,
        password=password,
        sender=sender,
        recipients=recipients,
        subject=subject,
        body_html=body_html,
        attachments=attachments,
        timeout=timeout
    )

def main():
    cfg = merged_config(".env")
    # Try non-interactive send if requested
    result = noninteractive_send_if_possible(cfg)
    if result is not None:
        ok, err = result
        if ok:
            print("Email sent successfully (non-interactive).")
            return
        else:
            print("Non-interactive send failed:", err)
            # fall back to interactive
    # Otherwise, run interactive with defaults from config
    try:
        interactive_main_with_config(cfg)
    except KeyboardInterrupt:
        print("\nOperation cancelled by user.")
        sys.exit(1)

if __name__ == "__main__":
    main()
